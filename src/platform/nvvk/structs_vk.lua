local header = 
[[
/* auto generated by structs_vk.lua */

/* Copyright (c) 2018, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

//////////////////////////////////////////////////////////////////////////
/**
  # function nvvk::make, nvvk::clear
  Contains templated `nvvk::make<T>` and `nvvk::clear<T>` functions that are 
  auto-generated by `structs.lua`. The functions provide default 
  structs for the Vulkan C api by initializing the `VkStructureType sType`
  field (also for nested structs) and clearing the rest to zero.

  ``` c++
  auto compCreateInfo = nvvk::make<VkComputePipelineCreateInfo>;
  ```
*/
 
#pragma once
]]

-- HOW TO USE
--
-- check out this and the other structs_vk files for write access
-- run with any lua5.1 compatible lua runtime (there is one shared_internal):
--
--    lua structs_vk.lua
--
-- within this directory. It will look for the VULKAN_SDK environment variable
-- which the VulkanSDK installer sets.

local function generate(outfilename, header)
  
  local override = {
    VkRayTracingShaderGroupCreateInfoNV = 
[[
  template<> inline VkRayTracingShaderGroupCreateInfoNV make<VkRayTracingShaderGroupCreateInfoNV>(){
    VkRayTracingShaderGroupCreateInfoNV ret = {VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV};
    ret.generalShader = VK_SHADER_UNUSED_NV;
    ret.closestHitShader = VK_SHADER_UNUSED_NV;
    ret.anyHitShader = VK_SHADER_UNUSED_NV;
    ret.intersectionShader = VK_SHADER_UNUSED_NV;
    return ret;
  }
]],
  }
  
  
  local sdkpath = os.getenv("VULKAN_SDK")
  assert(sdkpath, "Vulkan SDK not found")
  
  local vulkan = io.open(sdkpath.."/Include/vulkan/vulkan_core.h","rt")
  local str = vulkan:read("*a")
  vulkan:close()
  
  local version = str:match("VK_HEADER_VERSION%s+(%d+)")
  
  str = str.."\n\n#define VK_DUMMY_TERMINATOR_SPEC_VERSION 1\n"
  
  local outfile = io.open(outfilename, "wt")
  assert(outfile)
  
  local out = ""
  out = out.."  template <class T> T make(){ return T(); }\n"
  out = out.."  template <class T> void clear(T& ref){ ref = make<T>(); }\n"
  
  local structenums = {}
  local structextensions = {}
  local enumsstr = str:match("typedef enum VkStructureType {(.-)}")
  
  local function enumID(name)
    name = name:lower()
    name = name:gsub("_","")
    return name
  end
  
  for name in enumsstr:gmatch("VK_STRUCTURE_TYPE_([%w_]-) = %d+,") do
    structenums[enumID(name)] = "VK_STRUCTURE_TYPE_"..name
  end
  
  -- associate structs with extension
  -- not the best pattern since we will not catch the first extension (VK_KHR_surface) but we don't need to
  for extension,defstr in str:gmatch('#define VK_[%w_]+_EXTENSION_NAME%s+"([%w_]+)"\n(.-)#define VK_[%w_]+_SPEC_VERSION%s+%d+\n')
  do
    for name in defstr:gmatch('typedef struct Vk([%w_]+) {')
    do
      structextensions[name] = extension
    end
  end
  
  local structdefs     = {}
  local structexported = {}
  local structs = {}
  local lastextension = nil
  
  for name,defs in str:gmatch("typedef struct Vk([%w_]+)%s*(%b{})") do
    local enum = structenums[enumID(name)]
    
    local sname = "Vk"..name
    structdefs[sname] = defs
    
    if (enum) then
      local extension = structextensions[name]
      if (extension ~= lastextension) then
        if (lastextension) then
          out = out.."#endif\n"
        end
        if (extension) then
          out = out.."#if "..extension.."\n"
        end
        lastextension = extension
      end
     
      local complex = ""
      
      local function addComplex(prefix, defs)
        for typ, var in defs:gmatch("([%w_]+)%s+([%w_]+);") do
          local expenum = structexported[typ]
          local sdefs   = structdefs[typ]
          if (expenum) then
            complex = complex..prefix..var.." = {"..expenum.."};\n"
          elseif (sdefs) then
            addComplex(prefix..var..".", sdefs)
          end
        end
      end      
      addComplex("    ret.", defs)
      
      if (override[sname]) then
        out = out..override[sname]
        print("override", sname)
      elseif (complex ~= "") then
        out = out.."  template<> inline "..sname.." make<"..sname..">(){\n    "..sname.." ret = {"..enum.."};\n"..complex.."    return ret;\n  }\n"
        print("complex", sname)
      else
        out = out.."  template<> inline "..sname.." make<"..sname..">(){\n    return "..sname.."{"..enum.."};\n  }\n"
      end
      
      structexported[sname] = enum
    end
  end
  
  if (lastextension) then
    out = out.."#endif\n"
  end

  outfile:write("/* based on VK_HEADER_VERSION "..version.." */\n")
  outfile:write(header)
  outfile:write("namespace nvvk {\n")
  outfile:write(out)
  outfile:write("}\n")
  outfile:flush()
  outfile:close()
end

generate("structs_vk.hpp", header)