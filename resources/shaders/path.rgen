#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require

#include "utils/sampling.glsl"
#include "utils/material.glsl"
#include "utils/ray_payload.glsl"
#include "utils/uniform_buffer_object.glsl"
#include "utils/tone_mapping.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT scene_;
layout(binding = 1, rgba32f) uniform image2D output_image_;
layout(binding = 2, rgba32f) uniform image2D accumulation_image_;
layout(binding = 3) readonly uniform UniformBufferObjectStruct { UniformBufferObject ubo_; };
layout(binding = 7) readonly buffer LightArray { Light[] lights_; };

layout(location = 0) rayPayloadEXT RayPayload ray_;

vec3 getColorForRay(in vec3 start_ray_pos, in vec3 start_ray_dir, inout uint seed) {
    uint ray_flags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 10000.0;

    vec3 ret = vec3(0.0f, 0.0f, 0.0f);
    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);
    vec3 ray_pos = start_ray_pos;
    vec3 ray_dir = start_ray_dir;

    for (uint depth = 0; depth < ubo_.number_of_bounces; depth++) {
        // shoot a ray out into the world
        ray_.t = tmax;
        ray_.mat = getZeroedMaterial();
        ray_.missed = false;
        ray_.from_inside = false;
        traceRayEXT(scene_, ray_flags, cullMask, 0, 0, 0, ray_pos, tmin, ray_dir, tmax, 0);

        // if the ray missed, we are done
        if (ray_.missed) {
            ret += vec3(0.0) * throughput;// sky
            break;
        }

        if (ubo_.debug_normals) {
            vec3 n = remap(ray_.normal, -1.0f, 1.0f, 0.0f, 1.0f);
            ret = n;
            return ret;
        }

        if (ray_.from_inside) {
            throughput *= exp(-ray_.mat.refraction_color * ray_.t);
        }

        float specular_chance = ray_.mat.specular_chance;
        float refraction_chance = ray_.mat.refraction_chance;

        float ray_probability = 1.0f;
        if (specular_chance > 0.0f) {
            specular_chance = fresnelReflectAmount(
            ray_.from_inside ? ray_.mat.IOR : 1.0,
            !ray_.from_inside ? ray_.mat.IOR : 1.0,
            ray_dir,
            ray_.normal,
            ray_.mat.specular_chance,
            1.0f
            );

            float chance_multiplier = (1.0f - specular_chance) / (1.0f - ray_.mat.specular_chance);
            refraction_chance *= chance_multiplier;
        }

        float do_specular = 0.0f;
        float do_refraction = 0.0f;
        float ray_select_roll = randomFloat(seed);

        if (specular_chance > 0.0f && ray_select_roll < specular_chance) {
            do_specular = 1.0f;
            ray_probability = specular_chance;
        }
        else if (refraction_chance > 0.0f && ray_select_roll < specular_chance + refraction_chance) {
            do_refraction = 1.0f;
            ray_probability = refraction_chance;
        }
        else {
            ray_probability = 1.0f - (specular_chance + refraction_chance);
        }

        ray_probability = max(ray_probability, 0.001f);

        // update the ray position
        if (do_refraction == 1.0f) {
            ray_pos = (ray_pos + ray_dir * ray_.t) - ray_.normal * 0.001f;
        }
        else {
            ray_pos = (ray_pos + ray_dir * ray_.t) + ray_.normal * 0.001f;
        }

        // calculate new ray direction
        vec3 diffuse_ray_dir = normalize(ray_.normal + randomUnitVector(seed));

        vec3 specular_ray_dir = reflect(ray_dir, ray_.normal);
        specular_ray_dir = normalize(mix(specular_ray_dir, diffuse_ray_dir, ray_.mat.specular_roughness * ray_.mat.specular_roughness));

        vec3 refraction_ray_dir = refract(ray_dir, ray_.normal, ray_.from_inside ? ray_.mat.IOR : 1.0f / ray_.mat.IOR);
        refraction_ray_dir = normalize(mix(refraction_ray_dir, normalize(-ray_.normal + randomUnitVector(seed)), ray_.mat.refraction_roughness * ray_.mat.refraction_roughness));

        ray_dir = mix(diffuse_ray_dir, specular_ray_dir, do_specular);
        ray_dir = mix(ray_dir, refraction_ray_dir, do_refraction);

        // add in emissive light
        ret += ray_.mat.emissive * throughput;

        if (do_refraction == 0.0f) {
            throughput *= mix(ray_.mat.albedo, ray_.mat.specular_color, do_specular);
        }

        throughput /= ray_probability;

        // Russian Roulette
        float p = max(throughput.r, max(throughput.g, throughput.b));
        if (randomFloat(seed) > p) {
            break;
        }
        throughput *= 1.0f/p;
    }
    return ret;
}

void main() {
    vec3 pixel_color = vec3(0);

    for (int curr_sample = 0; curr_sample < ubo_.number_of_samples; curr_sample++) {
        uint seed = initRandom(gl_LaunchIDEXT.xy, ubo_.seed + ubo_.frame + curr_sample);

        const vec2 jitter = vec2(randomFloat(seed), randomFloat(seed)) - 0.5f;
        const vec2 uv_jittered = (gl_LaunchIDEXT.xy + jitter) / vec2(gl_LaunchSizeEXT.xy);
        const vec2 screen = uv_jittered * 2.0 - 1.0;

        vec4 origin = ubo_.model_view_inverse * vec4(0, 0, 0, 1);
        vec4 target = ubo_.projection_inverse * vec4(screen.x, screen.y, 1, 1);
        vec4 direction = ubo_.model_view_inverse * vec4(normalize(target.xyz), 0);

        pixel_color += getColorForRay(origin.xyz, direction.xyz, seed) / float(ubo_.number_of_samples);
    }

    vec4 last_frame_color = imageLoad(accumulation_image_, ivec2(gl_LaunchIDEXT.xy));
    float blend = (ubo_.frame < 2 || last_frame_color.a == 0.0) ? 1.0f : 1.0f / ( 1.0f + (1.0f / last_frame_color.a));
    pixel_color = mix(last_frame_color.rgb, pixel_color, blend);

    imageStore(accumulation_image_, ivec2(gl_LaunchIDEXT.xy), vec4(pixel_color, blend));

    // post processing
    pixel_color *= ubo_.exposure;

    if (ubo_.tone_map) {
        pixel_color = ACESFilm(pixel_color);
    }

    if (ubo_.gamma_correction) {
        pixel_color = linearToSRGB(pixel_color);
    }

    imageStore(output_image_, ivec2(gl_LaunchIDEXT.xy), vec4(pixel_color, blend));
}
